<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Composable State Space Models</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; } /* Keyword */
code > span.ch { color: #008080; } /* Char */
code > span.st { color: #008080; } /* String */
code > span.co { color: #008000; } /* Comment */
code > span.ot { color: #ff4000; } /* Other */
code > span.al { color: #ff0000; } /* Alert */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #008000; font-weight: bold; } /* Warning */
code > span.cn { } /* Constant */
code > span.sc { color: #008080; } /* SpecialChar */
code > span.vs { color: #008080; } /* VerbatimString */
code > span.ss { color: #008080; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #0000ff; } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ff4000; } /* Preprocessor */
code > span.do { color: #008000; } /* Documentation */
code > span.an { color: #008000; } /* Annotation */
code > span.cv { color: #008000; } /* CommentVar */
code > span.at { } /* Attribute */
code > span.in { color: #008000; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 66px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 71px;
  margin-top: -71px;
}

.section h2 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h3 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h4 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h5 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h6 {
  padding-top: 71px;
  margin-top: -71px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Composable POMP Models Documentation</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="SimulatingFromAModel.html">Simulating Data</a>
</li>
<li>
  <a href="AddingACustomModel.html">Adding A Model</a>
</li>
<li>
  <a href="ParticleFilter.html">Particle Filter</a>
</li>
<li>
  <a href="StreamingMCMC.html">MCMC</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Composable State Space Models</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#introduction-to-partially-observed-markov-process-models">Introduction to Partially Observed Markov Process Models</a></li>
<li><a href="#simulating-the-state-space">Simulating the State Space</a></li>
<li><a href="#simulating-a-single-model">Simulating a Single Model</a></li>
<li><a href="#composing-multiple-models">Composing Multiple Models</a></li>
<li><a href="#statistical-inference-the-particle-filter">Statistical Inference: The Particle Filter</a></li>
<li><a href="#inference-for-the-full-joint-posterior-distribution">Inference for the Full Joint Posterior Distribution</a></li>
<li><a href="#read-more">Read More</a></li>
</ul>
</div>

<p>This is the documentation for a <a href="https://git.io/statespace">Scala library for continuous time partially observed Markov processes</a> (POMP). Partially observed Markov processes can be used to model time series data, allowing interpolation and forecasting.</p>
<div id="introduction-to-partially-observed-markov-process-models" class="section level2">
<h2>Introduction to Partially Observed Markov Process Models</h2>
<p>Partially observed Markov processes are a type of <a href="https://en.wikipedia.org/wiki/State-space_representation">State Space Model</a>. This means the models feature unobserved, or latent, variables. The unobserved system state is governed by a <a href="https://en.wikipedia.org/wiki/Diffusion_process">diffusion process</a>, these are continuous time Markov processes meaning that future values of the state space, are independent from all previous values given the current state, x(t). A representation of a POMP model as a directed acyclical graph is below.</p>
<div class="figure" style="text-align: center">
<img src="index_files/figure-html/dag-1.png" alt="Representation of a POMP model as a Directed Acyclic Graph (DAG)" width="672" />
<p class="caption">
Representation of a POMP model as a Directed Acyclic Graph (DAG)
</p>
</div>
<p>The distribution, p, represents the Markov transition kernel of the state space. The distribution pi, represents the observation distribution, parameterised by the state space. The function f is a linear deterministic function, which can be used to add cyclic seasonal components to the state space. The function g is the linking-function from a <a href="https://en.wikipedia.org/wiki/Generalized_linear_model">generalised linear model</a>, which transforms the state space into the parameter space of the observation model. Define <span class="math inline">\(\gamma(t) = F^T_t \textbf{x}(t)\)</span> and <span class="math inline">\(\eta(t) = g(\gamma(t))\)</span>.</p>
</div>
<div id="simulating-the-state-space" class="section level2">
<h2>Simulating the State Space</h2>
<p>An example of a diffusion process is the <a href="https://en.wikipedia.org/wiki/Ornstein%E2%80%93Uhlenbeck_process">Ornstein-Uhlenbeck process</a>, which can be simulated by specifying the parameters of the process, <code>theta</code>, the mean of the process, <code>alpha</code> how quickly the process reverts to the mean and <code>sigma</code> the noise of the process. Then we must specify an initial state, which is done by drawing from a Gaussian distribution, since the exact solution to the OU process is a Gaussian distribution. Then we pass a <code>stepFunction</code> containing the exact solution to the OU process, relying on only the previous value of the realisation (because the process is Markovian) and the time difference between realisations.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> model.<span class="fu">StateSpace</span>.<span class="fu">_</span>
<span class="kw">import</span> model.<span class="fu">State</span>.<span class="fu">_</span>
<span class="kw">import</span> model.<span class="fu">OrnsteinParameter</span>
<span class="kw">import</span> model.<span class="fu">SimData</span>.<span class="fu">_</span>
<span class="kw">import</span> breeze.<span class="fu">stats</span>.<span class="fu">distributions</span>.<span class="fu">Gaussian</span>

<span class="kw">val</span> p = <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">1.0</span>, alpha = <span class="fl">0.05</span>, sigma = <span class="fl">1.0</span>)
<span class="kw">val</span> initialState = <span class="fu">LeafState</span>(<span class="fu">DenseVector</span>(<span class="fu">Gaussian</span>(<span class="fl">6.0</span>, <span class="fl">1.0</span>).<span class="fu">draw</span>))

<span class="kw">val</span> sims = <span class="fu">simSdeStream</span>(initialState, <span class="fl">0.0</span>, <span class="fl">300.0</span>, <span class="dv">1</span>, <span class="fu">stepOrnstein</span>(p))</code></pre></div>
<p>Notice, the state space can be multidimensional, and as such is represented by a <code>Vector</code>. A single state is represented by a LeafState, this will become clear when considering composition of models. The figure below shows a representation of the Ornstein-Uhlenbeck process with <code>theta = 6.0, alpha = 0.05, sigma = 1.0</code>.</p>
<p><img src="index_files/figure-html/ornstein-1.png" width="672" /></p>
</div>
<div id="simulating-a-single-model" class="section level2">
<h2>Simulating a Single Model</h2>
<p>The observations of a POMP can be from any parameterised distribution. The observation distribution depends on the latent variables and sometimes on additional parameters not in the system state, such as a scaling parameter representing measurement noise. A simple non-gaussian observation model, used for representing count data is the Poisson distribution, parameterised by it’s rate <span class="math inline">\(\lambda(t)\)</span>. If we consider the rate, <span class="math inline">\(\lambda(t)\)</span> to vary stochastically, then we can represent it using a POMP mode. Firstly select a representation of the state space, we will use the Ornstein-Uhlenbeck process from the previous example, then specify the parameters and the times the process should be observed. There is a <code>LeafParameter</code> class which combines the initial State, optional scale parameter and the state space parameters for a single model.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> model.{LeafParameter, GaussianParameter, OrnsteinParameter}
<span class="kw">import</span> model.<span class="fu">SimData</span>.<span class="fu">_</span>
<span class="kw">import</span> model.<span class="fu">POMP</span>.<span class="fu">PoissonModel</span>
<span class="kw">import</span> model.<span class="fu">StateSpace</span>.<span class="fu">_</span>

<span class="kw">val</span> p = <span class="fu">LeafParameter</span>(
  <span class="fu">GaussianParameter</span>(-<span class="fl">2.0</span>, <span class="fl">1.0</span>),
  None,
  <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">2.0</span>, alpha = <span class="fl">1.0</span>, sigma = <span class="fl">1.0</span>))
<span class="kw">val</span> mod = <span class="fu">PoissonModel</span>(stepOrnstein)


<span class="kw">val</span> times = (<span class="fl">1.0</span> to <span class="fl">100.0</span> by <span class="fl">1.0</span>).<span class="fu">toList</span>
<span class="kw">val</span> sims = <span class="fu">simData</span>(times, <span class="fu">mod</span>(p))</code></pre></div>
<p><img src="index_files/figure-html/poisson-1.png" width="672" /></p>
<p>The figure shows the state space, which varies along the whole real line and the transformed state space and Eta, which varies in <span class="math inline">\(\mathbb{R}^+\)</span> The linking function, g, is the log-link.</p>
</div>
<div id="composing-multiple-models" class="section level2">
<h2>Composing Multiple Models</h2>
<p>If we wish to consider more complex process, for instance a Poisson model with a seasonally varying rate, then we have to add deterministic values to the state before applying the observation distribution. The function, f, is a linear deterministic function which can be used to add seasonal factors to the system state.</p>
<p>Models are represented as a function from <code>Parameters =&gt; Model</code>, this means models are defined unparameterised. A function for combining two unparameterised models is <code>Model.combine</code>, this function is associative, but not commutative. This is because the function selects the leftmost Model’s observation and linking functions. The code snippet below shows how to construct a seasonal Poisson model, the observation distribution is Poisson, but the rate of an event occuring follows a daily (period T = 24) cycle if we assume count observations are made once every hour.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">val</span> poissonParams = <span class="fu">LeafParameter</span>(
    <span class="fu">GaussianParameter</span>(<span class="fl">0.0</span>, <span class="fl">1.0</span>),
    None,
    <span class="fu">BrownianParameter</span>(<span class="fl">0.1</span>, <span class="fl">0.3</span>))
  <span class="kw">val</span> seasonalParams = <span class="fu">LeafParameter</span>(
    <span class="fu">GaussianParameter</span>(<span class="fu">DenseVector</span>(Array.<span class="fu">fill</span>(<span class="dv">6</span>)(<span class="fl">0.0</span>)),
      <span class="fu">diag</span>(<span class="fu">DenseVector</span>(Array.<span class="fu">fill</span>(<span class="dv">6</span>)(<span class="fl">1.0</span>)))),
    None,
    <span class="fu">BrownianParameter</span>(Vector.<span class="fu">fill</span>(<span class="dv">6</span>)(<span class="fl">0.1</span>), Vector.<span class="fu">fill</span>(<span class="dv">6</span>)(<span class="fl">0.4</span>)))

  <span class="kw">val</span> params = poissonParams |+| seasonalParams
  <span class="kw">val</span> mod = <span class="fu">BernoulliModel</span>(stepBrownian) |+| <span class="fu">SeasonalModel</span>(<span class="dv">24</span>, <span class="dv">3</span>, stepBrownian)

  <span class="kw">val</span> times = (<span class="fl">1.0</span> to <span class="fl">100.0</span> by <span class="fl">1.0</span>).<span class="fu">toList</span>
  <span class="kw">val</span> sims = <span class="fu">simData</span>(times, <span class="fu">mod</span>(params))</code></pre></div>
<p><img src="index_files/figure-html/seasonalPoisson-1.png" width="672" /></p>
</div>
<div id="statistical-inference-the-particle-filter" class="section level2">
<h2>Statistical Inference: The Particle Filter</h2>
<p>If we have a fully specified model, ie the posterior distributions of the parameters given the data so far are available to us, then we can use a bootstrap particle filter (see <a href="https://www.springer.com/us/book/9780387951461">Sequential Monte Carlo Methods in Practice</a>) to determine the hidden state space of the observations. Consider the simulated Bernoulli model, the parameters are given by:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> p = <span class="fu">LeafParameter</span>(
  <span class="fu">GaussianParameter</span>(<span class="fl">6.0</span>, <span class="fl">1.0</span>),
  None,
  <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">6.0</span>, alpha = <span class="fl">0.05</span>, sigma = <span class="fl">1.0</span>))</code></pre></div>
<p>The bootstrap particle filter can be applied to the simulated data using a draw from the parameter posterior distribution and the inferred state space can be compared to the previously simulated state space. The data can be read in from a CSV or database, or simulated again. However, since these are stochastic models we can’t compare different realisations of the same model. The particle filter is using 1,000 particles.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">val</span> data = <span class="co">// poisson data</span>

  <span class="kw">val</span> p = <span class="fu">LeafParameter</span>(
    <span class="fu">GaussianParameter</span>(<span class="fl">6.0</span>, <span class="fl">1.0</span>),
    None,
    <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">6.0</span>, alpha = <span class="fl">0.05</span>, sigma = <span class="fl">1.0</span>))
  
  <span class="kw">val</span> mod = <span class="fu">BernoulliModel</span>(stepOrnstein)

  <span class="co">// Define the particle filter</span>
  <span class="kw">val</span> filter = Filter(mod.<span class="fu">model</span>, ParticleFilter.<span class="fu">multinomialResampling</span>, data.<span class="fu">map</span>(_.<span class="fu">t</span>).<span class="fu">min</span>)

  <span class="co">// Run the particle filter over the observed data using 1,000 particles</span>
  <span class="kw">val</span> filtered = filter.<span class="fu">filterWithIntervals</span>(data)(<span class="dv">1000</span>)(mod.<span class="fu">params</span>)</code></pre></div>
<p>The figure below shows the actual simulated state, plotted next to the estimate state and 99% <a href="https://en.wikipedia.org/wiki/Credible_interval">credible intervals</a>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">val</span> data = <span class="co">// poisson data</span>

  <span class="kw">val</span> p = <span class="fu">LeafParameter</span>(
    <span class="fu">GaussianParameter</span>(<span class="fl">6.0</span>, <span class="fl">1.0</span>),
    None,
    <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">6.0</span>, alpha = <span class="fl">0.05</span>, sigma = <span class="fl">1.0</span>))

  <span class="co">// declare a new filter type including the model, resampling scheme and starting time, t0</span>
  <span class="kw">val</span> filter = Filter(mod.<span class="fu">model</span>, ParticleFilter.<span class="fu">multinomialResampling</span>, t0 = <span class="fl">0.0</span>)
  
  <span class="co">// use the filter to return the state and credible intervals with 1000 particles</span>
  filter.<span class="fu">filterWithIntervals</span>(data)(<span class="dv">1000</span>)(mod.<span class="fu">p</span>)</code></pre></div>
<p><img src="index_files/figure-html/filteredPoisson-1.png" width="672" /></p>
</div>
<div id="inference-for-the-full-joint-posterior-distribution" class="section level2">
<h2>Inference for the Full Joint Posterior Distribution</h2>
<p>Say we have observed a time depending process in the real world, and don’t have the parameters available for the model. We wish to carry out inference for the state space and the parameters of the model simultaneously. This framework implements the Particle Marginal Metropolis Hastings (PMMH) Algorithm (see <a href="http://www.stats.ox.ac.uk/~doucet/andrieu_doucet_holenstein_PMCMC.pdf">Doucet et al. 2010</a>). The likelihood of the state space and parameters given the observations can be determined using a particle filter, then a standard Metropolis-Hastings update step is used to create a Markov Chain representing the full join posterior of the model given the observed real-world process.</p>
<p>Now we can implement the PMMH algorithm for the simulated Bernoulli observations, and determine if the algorithm is able to recover the parameters.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> data = <span class="co">// poisson data</span>

<span class="kw">val</span> p = <span class="fu">LeafParameter</span>(
  <span class="fu">GaussianParameter</span>(<span class="fl">6.0</span>, <span class="fl">1.0</span>),
  None,
  <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">6.0</span>, alpha = <span class="fl">0.05</span>, sigma = <span class="fl">1.0</span>))

<span class="kw">val</span> mod = <span class="fu">PoissonModel</span>(stepOrnstein)

<span class="co">// build the particle filter by selecting the model type and resampling scheme</span>
<span class="kw">val</span> filter = Filter(mod, ParticleFilter.<span class="fu">multinomialResampling</span>, <span class="fl">0.0</span>)

<span class="co">// specify the filter type (llFilter, to return estimate of log-likelihood),</span>
<span class="co">// the number of particles and observations</span>
<span class="kw">val</span> mll = filter.<span class="fu">llFilter</span>(data)(particles = <span class="dv">1000</span>) _

<span class="co">// build the PMMH algorithm using mll estimate (via particle filter), the</span>
<span class="co">// initial parameters and the proposal distribution for new paramters</span>
<span class="kw">val</span> mh = <span class="fu">ParticleMetropolis</span>(mll, p, Parameters.<span class="fu">perturb</span>(delta))

<span class="co">// run the PMMH as an akka stream in parallel (2 chains) and write the results to a file</span>
<span class="fu">runPmmhToFile</span>(s<span class="st">&quot;PoissonSimParams-$delta-$particles&quot;</span>, <span class="dv">2</span>, mod.<span class="fu">p</span>, mll, Parameters.<span class="fu">perturb</span>(<span class="fl">0.05</span>), <span class="dv">10000</span>)</code></pre></div>
<p>Note that the algorithm has been initialised at the same parameter values we used to simulate the model, this kind of prior information is not typically known for real world processes, unless similar processes have been extensively studied.</p>
</div>
<div id="read-more" class="section level2">
<h2>Read More</h2>
<ul>
<li>Use the navbar at the top, or consult <a href="SimulatingFromAModel.html">Simulating from a Model</a></li>
<li>The <a href="src/main/scala/examples">examples</a> directory.</li>
</ul>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
