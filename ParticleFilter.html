<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />




<title>Particle Filter</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/readable.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #0000ff; } /* Keyword */
code > span.ch { color: #008080; } /* Char */
code > span.st { color: #008080; } /* String */
code > span.co { color: #008000; } /* Comment */
code > span.ot { color: #ff4000; } /* Other */
code > span.al { color: #ff0000; } /* Alert */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #008000; font-weight: bold; } /* Warning */
code > span.cn { } /* Constant */
code > span.sc { color: #008080; } /* SpecialChar */
code > span.vs { color: #008080; } /* VerbatimString */
code > span.ss { color: #008080; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { } /* Variable */
code > span.cf { color: #0000ff; } /* ControlFlow */
code > span.op { } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #ff4000; } /* Preprocessor */
code > span.do { color: #008000; } /* Documentation */
code > span.an { color: #008000; } /* Annotation */
code > span.cv { color: #008000; } /* CommentVar */
code > span.at { } /* Attribute */
code > span.in { color: #008000; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 66px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 71px;
  margin-top: -71px;
}

.section h2 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h3 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h4 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h5 {
  padding-top: 71px;
  margin-top: -71px;
}
.section h6 {
  padding-top: 71px;
  margin-top: -71px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Composable POMP Models Documentation</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="SimulatingFromAModel.html">Simulating Data</a>
</li>
<li>
  <a href="AddingACustomModel.html">Adding A Model</a>
</li>
<li>
  <a href="ParticleFilter.html">Particle Filter</a>
</li>
<li>
  <a href="StreamingMCMC.html">MCMC</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Particle Filter</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#introduction-to-the-bootstrap-particle-filter">Introduction to the Bootstrap Particle Filter</a></li>
<li><a href="#filtering-a-stream-of-data">Filtering a Stream of Data</a></li>
<li><a href="#example-filtering-a-single-model">Example: Filtering a Single Model</a></li>
</ul>
</div>

<p>The particle filter is a highly flexible filter, used to perform Bayesian inference for non-linear and non-Gaussian state space models. It works by simulating many realisations of the state space in a particle cloud and determining which are the closest fit to observed data by calculating the observation likelihood. This type of simulation can be slow. The <a href="https://en.wikipedia.org/wiki/Kalman_filter">Kalman Filter</a> is an exact solution for calculating the latent state for Gaussian, Dynamic Linear Models. The Kalman Filter is very efficient and accurate as it doesn’t require simulation, but the class of models we consider can’t be solved analytically in closed form. Other filters, such as the Extended and Unscented Kalman Filter have been developed, which apply to non-linear state space models.</p>
<p>In our application, it is natural to use a particle filter. The particle filter can operate with observations arriving irregularly, it can handle non-Gaussian observation models and non-linear transformations.</p>
<div id="introduction-to-the-bootstrap-particle-filter" class="section level2">
<h2>Introduction to the Bootstrap Particle Filter</h2>
<p>Note, in this section we motivate and describe a simple application of the bootstrap particle filter to a Partially Observed Markov Process model. If you are already familiar with the bootstrap filter and would like to apply it using the API then please skip this section.</p>
<p>The bootstrap particle filter () is a simple filter able to estimate the state space of a POMP model. The latent state is governed by a transition kernel which we assume realisations can be simulated from, <span class="math inline">\(\textbf{X}(t_i) \sim p(\textbf{x}(t_i)|\textbf{x}(t_{i-1}))\)</span>. The process is observed through an observation model <span class="math inline">\(Y(t_i) \sim \pi(y(t_i) | \eta(t_i))\)</span>.</p>
<p>The bootstrap particle filter is used to calculate the unobserved system state by approximating the filtering distribution, <span class="math inline">\(p(\textbf{x}(t_i)| y(t_{0:i}))\)</span>. The algorithm to determine an empirical approximation of the unobserved system state at each observation time is presented below:</p>
<ol style="list-style-type: decimal">
<li>Initialise: Simulate <span class="math inline">\(N\)</span> particles from the initial distribution of the state space, <span class="math inline">\(\textbf{x}(t_0)^{(k)} \sim p(\textbf{x}(t_0))\)</span>, and set <span class="math inline">\(i = 1\)</span></li>
<li>Advance the state particle-cloud until the time of the next observation, <span class="math inline">\(\textbf{x}(t_i)^{(k)} \sim p(\textbf{x}(t_i)^{(k)}|\textbf{x}(t_{i-1})^{(k)})\)</span></li>
<li>Transform the each particle appropriately for the given observation model, <span class="math inline">\(\eta(t_i)^{(k)} = g(F^T_{t_i} \textbf{x}(t_i)^{(k)})\)</span></li>
<li>Calculate the weight of each particle, by calculating the likelihood of the observation given each particle: <span class="math inline">\(w^*(t_i)^{(k)} = \pi(y(t_i)|\eta(t_i)^{(k)})\)</span></li>
<li>Normalise the weights, <span class="math inline">\(w(t_i)^{(k)} = \frac{w^*(t_i)^{(k)}}{\sum_{j=1}^N w^*(t_i)^j}\)</span>, the particles and associated normalised weights forms a weighted sample from the filtering distribution <span class="math inline">\(p(\textbf{x}(t_i)| y(t_{1:i}))\)</span>, <span class="math inline">\(\{\textbf{x}(t_i)^{(k)}, w(t_i)^{(k)} | k = 1,\dots,N \}\)</span></li>
<li>Resample the state, by sampling with replacement <span class="math inline">\(N\)</span> times from a Multinomial distribution with each category representing a particle and the probability of choosing a particle represented by the associated weights, <span class="math inline">\(w(t_i)^{(k)}\)</span>. This gives an approximate random sample from <span class="math inline">\(p(\textbf{x}(t_i)| y(t_{0:i}))\)</span></li>
<li>If <span class="math inline">\(i = M\)</span> return the random samples from the filtering distribution <span class="math inline">\(p(\textbf{x}(t_i)| y(t_{0:i}))\)</span> at all time points, else set <span class="math inline">\(i = i + 1\)</span> and go to 2</li>
</ol>
<p>A simple illustrative particle filter can be implemented in Scala as follows:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> ParticleFilter {
    <span class="kw">import</span> math.{exp, log}
    <span class="kw">import</span> ParticleFilter.<span class="fu">_</span>

    <span class="kw">val</span> resample: (Vector[State], Vector[LogLikelihood]) =&gt; Vector[State]
    <span class="kw">val</span> stepFunction: (State, TimeInterval) =&gt; State
    <span class="kw">val</span> dataLikelihood: (State, Observation) =&gt; LogLikelihood
    <span class="kw">val</span> mean: Vector[LogLikelihood] =&gt; LogLikelihood = w =&gt; w.<span class="fu">sum</span>/w.<span class="fu">length</span>

    <span class="kw">def</span> <span class="fu">filterStep</span>(s: FilterState, y: Data): FilterState = {
        <span class="kw">val</span> dt = y.<span class="fu">time</span> - s.<span class="fu">t0</span>
  
        <span class="kw">val</span> x = <span class="fu">resample</span>(s.<span class="fu">particles</span>, s.<span class="fu">weights</span>)

        <span class="kw">val</span> x1 = s.<span class="fu">particles</span> <span class="fu">map</span> (<span class="fu">stepFunction</span>(_, dt))
        <span class="kw">val</span> w = x1 <span class="fu">map</span> (<span class="fu">dataLikelihood</span>(_, y.<span class="fu">observation</span>))

        <span class="kw">val</span> ll = s.<span class="fu">ll</span> + <span class="fu">log</span>(<span class="fu">mean</span>(w map exp))
 
        <span class="fu">FilterState</span>(x1, w, y.<span class="fu">time</span>, ll)
    }
}

<span class="kw">object</span> ParticleFilter {
    <span class="kw">type</span> Time = Double
    <span class="kw">type</span> Observation = Int
    <span class="kw">type</span> LogLikelihood = Double
    <span class="kw">type</span> State = Double
    <span class="kw">type</span> TimeInterval = Double

    <span class="kw">case</span> <span class="kw">class</span> <span class="fu">FilterState</span>(
        particles: Vector[State], 
        weights: Vector[LogLikelihood], 
        t0: Time, 
        ll: LogLikelihood)
    
    <span class="kw">case</span> <span class="kw">class</span> <span class="fu">Data</span>(time: Time, observation: Observation)
}</code></pre></div>
<p>This abstract trait we have defined above is a simple shell for a particle filter. In order to implement a concrete class representing a bootstrap filter for a specific model, let’s consider a simple model with a one-dimensional state-space and a Poisson observation model:</p>
<p><span class="math display">\[
\begin{align*}
N(t) &amp;\sim \textrm{Poisson}(\lambda(t)) \\
\lambda(t)|x(t) &amp;= \exp\{x(t)\} \\
\textrm{d}X(t) &amp;= \mu + \sigma \textrm{d}W(t)
\end{align*}
\]</span></p>
<p>This Poisson model’s latent state evolves according to generalised Brownian motion and the linking function, <span class="math inline">\(g\)</span>, is the exponential function, since the rate of a poisson distribution, <span class="math inline">\(\lambda(t)\)</span> is always positive. Now we must implement the functions declared in the trait <code>ParticleFilter</code>.</p>
<ul>
<li>The parameters of the model can be written as a case class, <code>m0</code> and <code>c0</code> represent the parameters of the initial distribution of the state, represented by a draw from a Gaussian distribution. <code>mu</code> and <code>sigma</code> are the parameters of the Markov transition kernel, which is generalised Brownian motion</li>
</ul>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">Parameters</span>(m0: Double, c0: Double, mu: Double, sigma: Double)</code></pre></div>
<ul>
<li>Advance the state according to generalised Brownian Motion</li>
</ul>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> breeze.<span class="fu">stats</span>.<span class="fu">distributions</span>.<span class="fu">Gaussian</span>

<span class="kw">def</span> <span class="fu">stepBrownian</span>(p: Parameters): (TimeInterval, State) =&gt; State = {
    (x, dt) =&gt; <span class="fu">Gaussian</span>(x + p.<span class="fu">mu</span> * dt, math.<span class="fu">sqrt</span>(p.<span class="fu">sigma</span> * p.<span class="fu">sigma</span> * dt)).<span class="fu">draw</span>
}</code></pre></div>
<ul>
<li>Calculate the weights of each particle given the observation</li>
</ul>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> breeze.<span class="fu">stats</span>.<span class="fu">distributions</span>.<span class="fu">Poisson</span>

<span class="kw">def</span> poissonLikelihood: (State, Observation) =&gt; LogLikelihood = {
  (x, y) =&gt; <span class="fu">Poisson</span>(<span class="fu">exp</span>(x)).<span class="fu">logProbabilityOf</span>(y)
}</code></pre></div>
<ul>
<li>Resample the states according to the likelihood weights, using Multinomial resampling</li>
</ul>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> breeze.<span class="fu">stats</span>.<span class="fu">distributions</span>.<span class="fu">Multinomial</span>
<span class="kw">import</span> breeze.<span class="fu">linalg</span>.<span class="fu">DenseVector</span>

<span class="kw">def</span> <span class="fu">multinomialResample</span>(x: Vector[State], w: Vector[LogLikelihood]): Vector[State] = {
  <span class="kw">val</span> xInd = <span class="fu">Multinomial</span>(<span class="fu">DenseVector</span>(w.<span class="fu">toArray</span>)).<span class="fu">sample</span>(x.<span class="fu">length</span>).<span class="fu">toVector</span>
  xInd <span class="fu">map</span> ( <span class="fu">x</span>(_) )
}</code></pre></div>
<ul>
<li>Now, put all the pieces together in a case class extending the <code>ParticleFilter</code> trait:</li>
</ul>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">
<span class="kw">case</span> <span class="kw">class</span> <span class="fu">PoissonPf</span>(p: Parameters) <span class="kw">extends</span> ParticleFilter {
  <span class="kw">val</span> stepFunction: (State, TimeIncrement) =&gt; State = <span class="fu">stepBrownian</span>(p)
  <span class="kw">val</span> dataLikelihood: (State, Observation) =&gt; LogLikelihood = <span class="fu">poissonLikelihood</span>(p)
  <span class="kw">val</span> resample: (Vector[State], Vector[LogLikelihood]) =&gt; Vector[State] = multinomialResample _
}</code></pre></div>
<p>In order to use the particle filter on a collection of data, we must first initialise a particle cloud of size <code>n</code> using the initial parameters and sampling <code>n</code> times from a Gaussian distribution:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> p = <span class="fu">Parameters</span>(<span class="fl">0.1</span>, <span class="fl">3.0</span>, <span class="fl">0.1</span>, <span class="fl">1.0</span>)
<span class="kw">val</span> particles = <span class="fu">Gaussian</span>(p.<span class="fu">m0</span>, p.<span class="fu">c0</span>).<span class="fu">sample</span>(n)</code></pre></div>
<p>Now, <code>filterStep</code> can be used on a <code>Stream</code> or <code>List</code> of data using <code>scanLeft</code>, the initial state of the particle filter is populated with <code>particles</code> and a vector of weights each equal to 1/n:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> data: Stream[Data] = \\ A stream of data
<span class="kw">val</span> pf = <span class="fu">PoissonPf</span>(p)
<span class="kw">val</span> init = <span class="fu">FilterState</span>(particles, Vector.<span class="fu">fill</span>(n)(<span class="fl">1.0</span>/n), ll = <span class="fl">0.0</span>, t0 = <span class="fl">0.0</span>)

data.<span class="fu">scanLeft</span>(init)(pf.<span class="fu">filterStep</span>)</code></pre></div>
<p>The marginal likelihood of the path given the observed data and parameters can be approximated by calculating the product of the average of the weights at each time point. This pseudo-marginal likelihood is used in the [[Particle Marginal Metroplis Hastings|Streaming-MCMC]] algorithm, which can be used to calculate the full joint posterior <span class="math inline">\(p(x, \theta | y)\)</span>. <code>filterStep</code> will calculate this, in conjunction with <code>scanLeft</code>, however, <code>scanLeft</code> emits each successive iteration. If the goal is to simply approximate the log-likelihood of a path, a simpler solution is to use <code>foldLeft</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">data.<span class="fu">foldLeft</span>(init)(pf.<span class="fu">filterStep</span>).<span class="fu">ll</span></code></pre></div>
</div>
<div id="filtering-a-stream-of-data" class="section level2">
<h2>Filtering a Stream of Data</h2>
<p>In order to filter information arriving in real-time, given we have access to the marginal posterior distribution of the parameters given the data so far, we simply apply the particle filter to each new observation arriving. However, the particle filter relies on the previous value of the particle cloud and the time difference between each observation since our models allow the possibility of irregularly observed data.</p>
<p>This means we need to store state in the stream, let’s first consider how to construct a stream of simulated data. We can use <code>Source.unfold</code> from <a href="https://akka.io">Akka streaming</a> which allows us to construct infinite streams, as long as the function returns a <code>Some</code>. The function starts with a zero value, then passes the first value of the tuple inside the <code>Some</code> back into the function. In this way we can easily construct Markov chains as streams.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> mod: Model = <span class="co">// a parameterised model</span>
<span class="kw">val</span> dt = <span class="fl">0.1</span> <span class="co">// the time step for the simulation</span>
<span class="kw">val</span> d0 = <span class="fu">simStep</span>(mod.<span class="fu">x0</span>.<span class="fu">draw</span>, <span class="fl">0.0</span>, dt, mod)

<span class="kw">val</span> sims = Source.<span class="fu">unfold</span>(d0)(x =&gt; Some((<span class="fu">simStep</span>(x.<span class="fu">sdeState</span>, x.<span class="fu">t</span> + dt, dt, mod), x))) </code></pre></div>
<p>Now we can simulate values from any model as a stream. Now we must apply a particle filter to the stream, assuming we don’t know the values of the latent variables, which of course we do because the data is simulated. In order to keep track of state, we can use a <code>scan</code>.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">val</span> n = <span class="dv">1000</span>
<span class="kw">val</span> t0 = <span class="fl">0.0</span>
<span class="kw">val</span> particleCloud = Vector.<span class="fu">fill</span>(n)(mod.<span class="fu">x0</span>.<span class="fu">draw</span>)
<span class="kw">val</span> initState = Vector(<span class="fu">PfState</span>(t0, None, particleCloud, State.<span class="fu">zero</span>, IndexedSeq[CredibleInterval]()))

observations.
  <span class="fu">scan</span>(initState)((d, y) =&gt; <span class="fu">filterStep</span>(y, d, mod, <span class="dv">200</span>))</code></pre></div>
<p><code>scan</code> accepts a zero value, <code>initState</code> and a function from a single observation, <code>y</code> and the previous state <code>d</code> to calculate the state given the current observation. Using <code>scan</code> in this way, outputs the value of the state as each observation is received.</p>
</div>
<div id="example-filtering-a-single-model" class="section level2">
<h2>Example: Filtering a Single Model</h2>
<p>Here we present an example of filtering a model with a Poisson observation model. First we simulate a Poisson model with an Ornstein-Uhlenbeck state space.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">import</span> model.{LeafParameter, GaussianParameter, OrnsteinParameter}
<span class="kw">import</span> model.<span class="fu">SimData</span>.<span class="fu">_</span>
<span class="kw">import</span> model.<span class="fu">POMP</span>.<span class="fu">PoissonModel</span>
<span class="kw">import</span> model.<span class="fu">StateSpace</span>.<span class="fu">_</span>

<span class="kw">val</span> p = <span class="fu">LeafParameter</span>(
  <span class="fu">GaussianParameter</span>(-<span class="fl">2.0</span>, <span class="fl">1.0</span>),
  None,
  <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">2.0</span>, alpha = <span class="fl">1.0</span>, sigma = <span class="fl">1.0</span>))
<span class="kw">val</span> mod = <span class="fu">PoissonModel</span>(stepOrnstein)


<span class="kw">val</span> times = (<span class="fl">1.0</span> to <span class="fl">100.0</span> by <span class="fl">1.0</span>).<span class="fu">toList</span>
<span class="kw">val</span> sims = <span class="fu">simData</span>(times, <span class="fu">mod</span>(p))</code></pre></div>
<p>The figure below shows a simulation from the Poisson model, the state space of the Ornstein-Uhlenbeck process can vary on the entire real line, the parameter space of the Poisson model is <span class="math inline">\(\mathbb{Z}^+\)</span> as the parameter, <span class="math inline">\(\lambda(t)\)</span>, is the mean of a counting process. The log-link function is used to transform the state space to the appropriate parameter space, <span class="math inline">\(\lambda(t) = g(x(t)) = \exp(x(t))\)</span></p>
<p><img src="ParticleFilter_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Now we can use the particle filter to estimate the state space, the scala code is given here and is available in the examples in the Github repo.</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">  <span class="kw">val</span> data = <span class="co">// poisson data</span>

  <span class="kw">val</span> p = <span class="fu">LeafParameter</span>(
    <span class="fu">GaussianParameter</span>(<span class="fl">6.0</span>, <span class="fl">1.0</span>),
    None,
    <span class="fu">OrnsteinParameter</span>(theta = <span class="fl">6.0</span>, alpha = <span class="fl">0.05</span>, sigma = <span class="fl">1.0</span>))

  <span class="co">// declare a new filter type including the model, resampling scheme and starting time, t0</span>
  <span class="kw">val</span> filter = Filter(mod.<span class="fu">model</span>, ParticleFilter.<span class="fu">multinomialResampling</span>, t0 = <span class="fl">0.0</span>)
  
  <span class="co">// use the filter to return the state and credible intervals with 1000 particles</span>
  filter.<span class="fu">filterWithIntervals</span>(data)(<span class="dv">1000</span>)(mod.<span class="fu">p</span>)</code></pre></div>
<p><img src="ParticleFilter_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});


</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
