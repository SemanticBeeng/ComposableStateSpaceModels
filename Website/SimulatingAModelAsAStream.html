<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Practicalities of working with streaming data</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>





<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>When modelling real world data from sensor networks, such as the <a href="http://uoweb1.ncl.ac.uk/">Urban Observatory</a> or the <a href="https://www.netraveldata.co.uk/">NE Open Data Service</a> we can consume the data as it is recorded. In order to consume the data as it arrives, it makes sense to use a <a href="http://www.reactive-streams.org/">reactive stream</a>, <a href="http://akka.io/">Akka Streams</a> are an implementation of reactive streams. Statistical modelling is computationally intensive, so if the number of incoming observations increases due to a variable sampling rate of a sensor then we want to implement a backpressure strategy to reduce or buffer the amount of incoming data. For instance we could drop every other observation if it was determined that this wouldn&#39;t affect the quality of the inference significantly, or we could buffer the extra observations and wait until the sampling rate of the sensor declines again to catch up.</p>

<p>In order to test the inference algorithms, it is useful to simulate data from the models, but in the format we expect to receive the real data. Since the models are Markov processes, the stream must keep track of the previous state. We must build an actor system from the Akka stream, then specify the model and parameters.</p>

<pre><code class="scala">  import model.Parameters._
  import model.POMP.BernoulliModel
  import model.StateSpace.stepOrnstein
  import model.SimData._

  import akka.actor.ActorSystem
  import akka.stream.ActorMaterializer
  import akka.stream.scaladsl._
  import scala.concurrent.ExecutionContext.Implicits.global

  implicit val system = ActorSystem(&quot;SimulateBernoulliOnline&quot;)
  implicit val materializer = ActorMaterializer()

  val p = LeafParameter(
    GaussianParameter(6.0, 1.0),
    None,
    OrnsteinParameter(theta = 6.0, alpha = 0.05, sigma = 1.0))

  val mod = BernoulliModel(stepOrnstein)(p)

  val sims = simStream(mod, precision = 0, t0 = 0.0)
</code></pre>

<p><code>simStream</code> uses the <code>unfold</code> method which constructs an infinite stream starting from a zero value, the stream will terminate if it receives a <code>None</code>, the function signature is:</p>

<pre><code class="scala">def unfold[S, E](s: S)(f: S =&gt; Option[(S, E)]): Source[E, NotUsed]
</code></pre>

<p><code>s</code> represents the zero value, in our case a simulation from the initial state represented by <code>Gaussian(6.0, 1.0)</code>, along with a simulated observation and time, <code>t0 = 0.0</code>. The function <code>f</code> maps to an <code>Option</code> containing a tuple, the first element of the tuple is passed to <code>f</code> for each subsequent iteration, as long as the <code>Option</code> returns <code>Some</code> the stream will iterate. </p>

<h2>Practicalities of working with streaming data</h2>

<p>Now we can print this infinite stream of simulations to the console, or write them to a file, or use a particle filter to perform inference. However, if we try printing the stream to the console we can&#39;t see the numbers as they fly past, how about throttling the stream:</p>

<pre><code class="scala">import scala.concurrent.duration._

val throttled = sims.
  zip(Source.tick(1 second, 1 second, ())).
  map { case (s,_) =&gt; s }.
  runForeach(println)
</code></pre>

<p>This pipeline zips a ticking <code>Source</code> of <code>Unit</code>, the discards the unit and prints each observation on a new line. This will print a new observation each second, forever. We can also limit the number of items we generate using <code>take</code>:</p>

<pre><code class="scala">throttled.
  take(100).
  runForeach(println)
</code></pre>

<p>Another option is thinning the stream, discarding every other simulation:</p>

<pre><code class="scala">throttled.
  zip(Source.from(1)).
  filter { case (_, i) =&gt; i % 2 == 0 }.
  map { case (a, _) =&gt; a }.
  runForeach(println)
</code></pre>

<p>We can also use the <a href="The-Particle-Filter">particle filter</a> on the data as a stream, and group observations into chunks and use the <a href="Streaming-MCMC">Particle Marginal Metropolis Hastings</a> algorithm.</p>

</body>

</html>
